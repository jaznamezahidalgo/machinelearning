# -*- coding: utf-8 -*-
"""DataReview.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1G-SoPd-W-UitOWlgRrFcpIfmgkuSWuRt
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

from matplotlib import cm
from matplotlib import colors
import plotly.express as px

class DataReview(object):
  def __getattr__(self, name: str):
      return object.__getattribute__(name)

  def __setattr__(self, name: str, value):
      self.__dict__[name] = value  
  
  def from_csv(self, file_source : str):
    self.data_frame = pd.read_csv(file_source, index_col = 0)
    self.setting()
    return self

  def from_data_frame(self, data :np.DataFrame):
    self.data_frame = data
    self.setting()
    return self

  def setting(self):
      self.num_observations = self.data_frame.shape[0]
      self.num_features = self.data_frame.shape[1]
      self.features_names = self.data_frame.columns 

  def view_statistics(self, include : str = None):
    if include == None:
      return self.data_frame.describe()
    if include.lower() == 'categorical':
      return self.data_frame.describe(include = np.object0)

  def view_class_distribution(self, column : str):
    return self.data_frame[column].value_counts()

  def view_correlation(self, columns : np.array = None, 
    style = None, high = 10, width = 10, annot :bool = True):
    plt.figure(figsize=(high, width))
    data = self.data_frame if columns == None else self.data_frame[columns]
    m_correlation = data.corr()
    if style == None:
      sns.heatmap(m_correlation, annot=annot, cmap='Blues_r')
    else:
      mask = np.zeros_like(m_correlation)
      mask[np.triu_indices_from(mask)] = True
      with sns.axes_style("white"):
        sns.heatmap(m_correlation, mask=mask, vmax=.3, square=True, annot=annot) 
    plt.title("Correlación entre las características", fontsize=18, fontweight="bold")
    plt.show()

  def view_correlation_by_two_columns(self, x : str, y : str):
    fig, ax = plt.subplots(1, 1, figsize=(6,4))
    ax.scatter(x=self.data_frame[x], y=self.data_frame[y], alpha= 0.8)
    plt.title(x.upper() + " versus " + y.upper(), fontsize=18, fontweight = "bold")
    ax.set_xlabel(x, fontsize=14)
    ax.set_ylabel(y, fontsize=14);
  
  def view_outliers(self, x : str, y : str):
    plt.figure(figsize=(10,10))
    sns.boxplot(x=x.lower(), y = y.lower(), data=self.data_frame)
    plt.title("Outliers {}".format(y.capitalize()))
    plt.show()

  def view_outliers_by_column(self, x : str):
    x_unique, counts = np.unique(self.data_frame[x], return_counts=True)
    sizes = counts*20
    colors = ['blue']*len(x_unique)
    colors[-1] = 'red'
 
    plt.axhline(1, color='k', linestyle='--')
    plt.scatter(x_unique, np.ones(len(x_unique)), s=sizes, color=colors)
    plt.title("Outliers de {}".format(x.upper()), fontsize=14, fontweight="bold")
    plt.xlabel("Valores", fontsize=14)
    plt.yticks([])
    plt.show()

  def view_graph_interactive(self, x :str, y :str, hover : str):
    fig = px.scatter(self.data_frame, x = x, y = y, color = hover,
                 hover_name = self.data_frame[hover].values,  width = 600, height = 600, 
                 labels = {'x' : x, 'y' : y, hover : hover}, title = "{0} para {1} versus {2}".format(hover, x, y))
    fig.show()    
  
  def summary(self):
    d_tipos, d_nulos, d_count = pd.DataFrame(), pd.DataFrame(), pd.DataFrame()
    d_tipos['name'] = pd.DataFrame(self.data_frame.dtypes).index
    d_tipos['type'] = pd.DataFrame(self.data_frame.dtypes)[0].values

    d_nulos['name'] = pd.DataFrame(self.data_frame.isnull().any()).index
    d_nulos['isNull'] = pd.DataFrame(self.data_frame.isnull().any())[0].values

    d_count['name'] = pd.DataFrame(self.data_frame.isnull().sum()).index
    d_count['count.null'] = pd.DataFrame(self.data_frame.isnull().sum())[0].values

    return pd.merge(pd.merge(d_tipos, d_nulos, on = 'name'), d_count, on="name")    
  
  def count_by_column(self, column : str, ordered = False, ascending=True):
    indexes = self.data_frame.groupby(column)[column].count().index
    values = self.data_frame.groupby(column)[column].count().values
    if ordered:
      return pd.DataFrame(values, columns = ['TOTAL'], index = indexes).sort_values('TOTAL', ascending = ascending)
    return pd.DataFrame(values, columns = ['TOTAL'], index = indexes)
  
  def statistics_by_column(self, group_by : str, column : str, 
    metrics : np.array, sorted_by : str = None):

    if sorted_by is None:
      return self.data_frame.groupby(group_by)[column].aggregate(metrics)
    return self.data_frame.groupby(group_by)[column].aggregate(metrics).sort_values(by=sorted_by)
  
  def describe_by_column(self, column : str):
    return self.data_frame[column].describe()
  
  def get_categorical_features(self):
    tipos = self.data_frame.columns.to_series().groupby(self.data_frame.dtypes).groups
    # Conociendo la lista de columnas categóricas
    return tipos[np.dtype('object')]
  
  def get_numeric_features(self):
    columnas = self.data_frame.columns
    return list(set(columnas) - set(self.get_categorical_features()))  

  def null_treatment(self, which='all', replace_numeric='mean'):
    """
      which = 'all' | 'numeric' | 'categorical'
      replacce_numeric = 'mean' | 'median'
    """
    if which == 'all' or which == 'numeric':
      # Completando valores faltantes datos cuantititavos
      for columna in self.get_numeric_features():
        if replace_numeric == 'mean':
          mean = self.data_frame[columna].mean()
          self.data_frame[columna] = self.data_frame[columna].fillna(mean)  
        if replace_numeric == 'median':
          median = self.data_frame[columna].median()
          self.data_frame[columna] = self.data_frame[columna].fillna(median)           
    if which == 'all' or which == 'categorical':
      # Completando valores faltantes datos categóricos
      for columna in self.get_categorical_features():
        mode = self.data_frame[columna].mode()[0] 
        self.data_frame[columna] = self.data_frame[columna].fillna(mode)    
  
  def view_features_with_null(self):
    return self.summary()[self.summary().isNull]
  def __str__(self):
    return "Observations : {0}\nFeatures : {1}\nNames features : {2}".format(self.num_observations, 
                                                                            self.num_features, self.features_names)